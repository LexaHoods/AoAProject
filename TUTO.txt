##############Tutoriel incluant les commandes et des réponses à des questions éventuelles################""

Questions :
1) Est ce pertinent d'afficher le nombre de calcul par cycle ?(c'est-à-dire de faire des graphiques ?) (nouveau fichier PROJET2.c , oubliez le PROJET.c d'avant)
2) Comment interpréter les résultats maqao / qu'est ce qui est pertinent dans le résultat maqao pour le rendu attendu ?
3) Comment justifier les points d'implémentation de driver, qu'est ce qui est attendu de nous ?

1)

> Courbes pertinente permet de trouver le warmup => idéal courbe la plus plate possible
> Faire un calcul max-min / min qui donne une dispersion, on veut qu'elle soit à moins de 10 % (bientôt implémenté dans le projet2.c)

>Calcul du temps de warmup => visé 0,5s (bientôt implémenté dans le projet2.c)

2)
Pour le rapport Global et Rapport Individuel :
*********************************************
  a)Regarder les résultat dans la section loop , double clic sur baseline
  b)Regarder les différents taux de vectorization => indique que le code n'est pas vectoriser par exemple
  c)Regarder le code assembleur  pour comparer

  Refaire a,b,c avec chaque flags de compil et faire un tableau récapitulatif.

Pour le rapport individuel :
***************************
En fonction du cache,faire un tableau qui montre quel flag de compil sont les plus performants (ICC/GCC)
(regarder la moyenne des nombres de cycles par opérations (bientôt implémenté dans projet2.c))


3)
Rapport global :
****************
4) justifier les points d'implémentations de driver :
 a) A quoi sert le warmup ?
    Réponse : c'est pour vider ta mémoire de ce qu'il y avait avant et la preparer a faire les calculs de la fonction baseline.
    Pourquoi ce nombre de warmup ?
    Réponse : (quand la partie 1) sera fait on aura la réponse)
 b) Indiquer pourquoi nous affichons des opérations/cycles
    (dispersion,moyenne de debit,affichage du temps de warmup)

 c) Pourquoi les répétitions et pourquoi ce nombre de répétitions ?

 d) Pourquoi des Metas-répétitions et pourquoi ce nombre de metas-répétitions ?

 e) Pourquoi on a initialisé ces tableaux de cette façon la ?



*******************************************************************

Commandes pour mesurer correctement la performance du programme :
 *Avant propos*
  Brancher le pc sur secteur
  Fermer tous les programmes (firefox etc)

 *Fixer la fréquence du cpu*
  Pour trouver à quel fréquence la fixer : sudo cpupower -c 0-3 frequency-info
  Une fois la fréquence max trouver :
  sudo cpupower -c 0-3 frequency-set -u 4.1GHz (par exemple pour moi c'est 4.1GHz)

  *Compiler le programme*
  (Ne pas oubliez de faire un pull du git ! new makefile coming soon)
   Faire : make
   On aura deux programme en sorties : projet et projeticc
   (un programme compilé par gcc et un programme compilé par icc, les flags faut les modifier directement dans le makefile)

  *Executer le programme seul*
    commande à faire : taskset -c 1 ./projet 300 100 30
    (Taskset pour éviter les erreurs de changement de contexte (programme executé seulement sur un coeur))
    (Modifier les valeurs en paramètre, par exemple 300 ici correspond à la taille du tableau, 100 au nombre de répétitions de warmup et 30 au nombres de répétitions du programme )
  *Afficher la courbe pour le warmup*
    commande : ./plot.sh
    (Donne un png de la courbe warmup, elle doit être la plus stable possible ! pas de pic !!)

  *Executer le programme avec makao*
  commande :
   sudo maqao oneview --create-report=one binary=projet run_command="<binary> 380 380 30" pinning_command="taskset -c 1"

  (Changer les chiffres pour votre test, et le binary projet pour gcc et projeticc pour icc)

  *Voir l'utilisation en temps réel du cache avec likwid du programme*
     sudo likwid-perfctr -g L3 taskset -c 1 ./projet 300 100 30

     (Par exemple pour L3)
